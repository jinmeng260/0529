一、git简介
分布式版本控制系统
由linus编写开发
集中式VS分布式


二、安装git
1.Debian或Ubuntu Linux：
sudo apt-get install git  #直接完成Git的安装

2.其他Linux版本：
可以直接通过源码安装。先从Git官网下载源码，然后解压，依次
./config
make
sudo make install

3.Windows上安装Git：
Cygwin模拟环境，Git也一样。
msysgit是Windows版的Git，从https://git-for-windows.github.io
安装完成后，在开始菜单里找到“Git”->“Git Bash”

4.Mac OS X上安装Git：
有两种安装Git的方法。
一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。
二更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode
选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以了


安装完成后，还需要最后一步设置，在命令行输入：
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"

三、创建版本库
版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”

1.创建一个版本库：
#先创建一个目录：
mkdir learngit
cd learngit

#git init #目录变成Git可以管理的仓库：

2.文件添加到版本库
git不能管理二进制文件,管理纯文本文件,最好使用标准的UTF-8编码
不建议使用windows自带的txt编辑器

git add readme.txt
git commit -m "wrote a file"


3.小结
初始化一个Git仓库，使用git init命令。
添加文件到Git仓库，分两步：
第一步，使用命令git add <file>，注意，可添加多个文件；
第二步，使用命令git commit，完成。


四、
1.git status #查看当前仓库的状态
git diff readme.txt #查看文件改动

2.版本回退
文件修改到一定程度的时候，就可以“保存一个快照”--commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作。

git log #显示从最近到最远的提交日志
输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数

HEAD #表示当前版本
HEAD^ #上一个版本
HEAD~100 #上100个版本

回退到上一个版本：
git reset --hard HEAD^

git reset --hard 3626738 #指定commit-id

当你回退版本的时候，Git仅仅是把HEAD从指向HEAD，然后顺便把工作区的文件更新

git reflog #查看每一个命令

---小结：

现在总结一下：

HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。

穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

3.工作区和暂存区：
工作区working directory
版本库repository， .git/
	暂存区stage(index)

把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

创建Git版本库时，Git自动为我们创建了唯一个master分支，所以，git commit就是往master分支上提交更改。

理解为，需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。

git add命令实际上就是把要提交的所有修改放到暂存区（Stage）
git commit就可以一次性把暂存区的所有修改提交到分支


4.管理修改
Git跟踪并管理的是修改，而非文件。

5.撤销修改
git checkout -- readme.txt #把readme.txt文件在工作区的修改全部撤销
这里有两种情况：
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

总之，就是让这个文件回到最近一次git commit或git add时的状态。

如果已经add到暂存区里,修改撤销掉（unstage），重新放回工作区：
git reset HEAD file

git reset既可以回退版本，也可以把暂存区的修改回退到工作区。用HEAD时，表示最新的版本。

如何丢弃工作区的修改吗？
git checkout -- readme.txt
git status

小结:
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步git checkout -- readme.txt

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，git reset --hard commitid


6.删除文件
rm命令删了：
rm test.txt
这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了

要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：
git rm test.txt
git commit -m "remove test.txt"
文件就从版本库中被删除了。

另一种情况是删错了，所以可以很轻松地把误删的文件恢复到最新版本：
git checkout -- test.txt
git checkout是用版本库里的版本替换工作区的版本，都可以“一键还原”。

小结：
命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。

五、远程仓库
1.注册github,添加ssh key：
注册一个GitHub账号，就可以免费获得Git远程仓库。

第1步：创建SSH Key：
ssh-keygen -t rsa -C "youremail@example.com"
你需要把邮件地址换成你自己的邮件地址，然后一路回车

第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：
点“Add Key”，你就应该看到已经添加的Key

GitHub上免费托管的Git仓库，任何人都可以看到

2.创建远程仓库：

echo "# 0529" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/jinmeng260/0529.git
git push -u origin master
--------------
git remote add origin git@github.com:jinmeng260/0529.git

添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的。
下一步，就可以把本地库的所有内容推送到远程库上：
git push -u origin master #实际上是把当前分支master推送到远程。


小结：
要关联一个远程库：
git remote add origin git@server-name:path/repo-name.git；

关联后：
git push -u origin master #第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作

3.从远程库克隆：
假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。
1.登陆GitHub，创建一个新的仓库，名字叫gitskills：
2.下一步是用命令git clone克隆一个本地库：
git clone git@github.com:jinmeng260/0529.git
cd 0529

六、分支管理
1.创建和合并分支

每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。
在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：
每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：

当我们创建新的分支,Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上
Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了

git checkout -b dev
git branch #列出所有分支,查看当前分支
git checkout master
git merge dev #git merge命令用于合并指定分支到当前分支。

小结:
Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>


2.解决冲突
master分支和feature1分支各自都分别有新的提交，变成了这样
这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突
#git merge feature1
Auto-merging readme.txt
CONFLICT (add/add): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.

#cat readme.txt 
<<<<<<< HEAD
test
conflict
=======
Creating a new branch is quick AND simple.
>>>>>>> feature1

删除冲突,git add-git commit->冲突解决

git config --list
git config --global color.ui true #显示高亮

小结:
当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
用git log --graph命令可以看到分支合并图。

3.git 分支管理策略
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

下面我们实战一下--no-ff方式的git merge：
首先，仍然创建并切换dev分支：
git checkout -b dev
修改readme.txt并提交
git add readme.txt
git commit -m "add merge"
切回master
git checkout master

准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：
git merge --no-ff -m "merge with no-ff" dev
git log --graph --pretty=oneline --abbrev-commit

分支策略:
在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
每个人都有自己的分支，时不时地往dev分支上合并就可以了。


小结:
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。

4.bug分支

Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。
此时用git status查看工作区，就是干净的，因此可以放心地创建分支来修复bug。

1)首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：
git checkout master
git checkout -b issue-101

2)现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：
git add readme.txt
git commit -m "fix bug 101"

3)修复完成后，切换到master分支，并完成合并，最后删除issue-101分支
git checkout master
git merge --no-ff -m "merge bug fix 1010" issue-101

git branch -d issue-101

4)原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！
git checkout dev
git status

5)刚才的工作现场存到哪去了？用git stash list命令看看
git stash list

恢复现场
a.git stash apply #恢复后，stash内容并不删除
  git stash drop #删除stash内容
b.git stash pop #恢复的同时把stash内容也删了

可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
git stash apply stash@{0}
  
小结:
修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；
当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。


5.feature分支：
每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。
丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。

6.多人协作：
当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。
要查看远程库的信息：
git remote

git remote -v #显示更详细的信息

推送分支：
git push origin master  #把该分支的所有本地提交推送远程库。推送时指定本地分支
git push origin dev #推送dev分支

哪些分支需要推送至远程：
1)master需要和远程同步
2)dev也需要同步
3)bug分支,不必要推送到远程
4)feature分支

抓取分支：
模拟克隆远程仓库
git clone git@github.com:jinmeng260/third.git

克隆后默认只能看到master分支
如果要在dev分支上开发,就必须创建远程origin的dev分支到本地：
git checkout -b dev origin/dev

现在就可以再dev上修改并不时的push到远程
git commit -m "add test"

git branch --set-upstream dev origin/dev #设置本地dev和origin/dev链接
git pull 


多人协作的工作模式通常是这样：
1)首先，可以试图用git push origin branch-name推送自己的修改；
2)如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
3)如果合并有冲突，则解决冲突，并在本地提交；
4)没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！
5)如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建
用命令git branch --set-upstream branch-name origin/branch-name。

小结:
查看远程库信息，使用git remote -v；

本地新建的分支如果不推送到远程，对其他人就是不可见的；
从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
在本地创建和远程分支对应的分支:git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。


七、标签管理
发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。
标签也是版本库的一个快照。

Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针，创建和删除标签都是瞬间完成的。
tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。

1.创建标签
git checkout master #切换到分支
git tag v1.0 #打标签

git log --pretty=oneline --abbrev-commit #查看log
git tag v0.9 6224937 #指定commit打标签
git tag #查看标签

git show v0.9 #查看标签信息
git tag -a v0.1 -m "version 0.1 released" 3628164 #指定标签名和说明文字
git tag -s v0.2 -m "signed version 0.2 released" adga12 #私钥签名,签名采用PGP签名,必须先安装gpg（GnuPG）

小结:
命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；
git tag -a <tagname> -m "blablabla..."可以指定标签信息；
git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；
命令git tag可以查看所有标签。

2.标签操作：
git tag -d v0.1
创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。
要推送某个标签到远程，使用命令:
git push origin v0.1

一次性推送全部尚未推送到远程的本地标签：
git push origin --tags

标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：
git tag -d v0.9
git push origin :refs/tags/v0.9 #远程删除标签

小结：
git push origin <tagname>可以推送一个本地标签；
git push origin --tags可以推送全部未推送过的本地标签；
git tag -d <tagname>可以删除一个本地标签；
git push origin :refs/tags/<tagname>可以删除一个远程标签。


八、使用GitHub
如何参与一个开源项目呢？比如人气极高的bootstrap项目，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：

一定要从自己的账号下clone仓库，这样你才有权限推送修改。

如果你想修复bootstrap的一个bug，或者新增一个功能，干完后，往自己的仓库推送。
如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。

九、自定义git
让Git显示颜色，会让命令输出看起来更醒目：
git config --global color.ui true

1.忽略特殊文件
.gitignore

忽略文件的原则是：
1)忽略操作系统自动生成的文件，比如缩略图等；
2)忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；
3)忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。

小结:
忽略某些文件时，需要编写.gitignore；
.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！

2.配置别名：
git config --global alias.st status #status别名为st
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.br branch

--global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。
git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：
git config --global alias.unstage "reset HEAD"
git unstage test.py #即可撤销暂存区的修改

配置git last让其显示最后一次提交
git config --global alias.last 'log -1'

配置git lg：
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"


配置文件：
--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。

每个仓库的Git配置文件都放在.git/config文件中：

别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。
当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中


3.搭建git服务器：
推荐ubuntu或debian搭建git服务器
1)sudo apt-get install git
2)sudo adduser git #创建git用户
3)创建证书登陆,用来收集所有要登录的用户的公钥
公钥导入 /home/git/.ssh/authorized_keys
4)初始化git仓库
mkdir /srv/sample.git && cd /srv/
sudo git init --bare sample.git #创建一个裸仓库,裸仓库没有工作区
sudo chown -R git:git sample.git #owner改为git

5)禁用shell登陆
vi /etc/passwd
git:x:1001:1001:,,,:/home/git:/bin/bash改为：
git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell

6)克隆远程仓库
git clone git@server:/srv/sample.git
 

管理公钥：
如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就可以用Gitosis来管理公钥。

管理权限：
有的公司会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。


小结：
搭建Git服务器非常简单，通常10分钟即可完成；
要方便管理公钥，用Gitosis
要像SVN那样变态地控制权限，用Gitolite。

====================================================================================
git命令总结：

配置全局用户及邮箱
git config --global user.name "Your Name"
git config --global user.email "email@example.com"

配置当前仓库用户及邮箱
git config user.name "Your Name"
git config user.email "email@xx.com"

查看配置文件内容
git config --list

初始化版本库
git init  

把文件放到 git 仓库
git add

把文件提交到 git 仓库
git commit -m "xxx"

查看当前仓库状态
git status

查看文件修改
git diff <file>

评论区
git diff    #是工作区(work dict)和暂存区(stage)的比较
git diff --cached    #是暂存区(stage)和分支(master)的比较
git diff HEAD  #查看工作区和版本库里面最新版本的区别

查看提交日志 
git log git log --pretty=oneline

版本回退到上一个版本
git reset --hard HEAD^
git reset --hard 3628164

查看命令日志
git reflog

丢弃工作区修改
git checkout -- file

撤销暂存区修改
git reset HEAD file

删除暂存区文件
git rm <file>
git commit -m "xxxx"

从暂存区恢复删除文件
git checkout -- <file>

关联远程仓库
git remote add origin git@server-name:path/repo-name.git

首次 push 到远程仓库
git push -u origin master 

非首次推送到远程仓库
git push origin master 

从远程仓库克隆
git clone git@server-name:path/repo-name.git

分支管理
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>
禁止使用 fast forward merge 方式
git merge --no-ff -m "xxx"  <branch name>

隐藏现场及恢复现场
git stash #保存现场
git stash pop #恢复现场

强制删除未合并分支
git branch -D <branch name>

多人协作
git remote #查看远程库信息
git remote -v #查看远程库信息详细
git push origin master #推送本地 master 分支
git checkout -b dev origin/dev #创建本地 dev 并关联远程 dev 分支
git branch --set-upstream branch-name origin/branch-name #建立本地分支与远程分支得关联
git pull #抓取远程分支

创建标签
git tag <name>  #创建标签
git tag #查看所有标签
git tag v0.9 6224937 #对某一次 commit 打标签
git show <tagname> #查看标签信息
git tag -a v0.1 -m "version 0.1 released" 3628164 #创建有说明的标签

操作标签
git tag -d v0.1 #删除标签
git push origin <tagname> #推送标签到远程
git push origin --tags #推送本地所有未推送到远程的标签
git push origin :refs/tags/<tagname> #删除远程标签

自定义git
git config --global color.ui true #配置颜色开启
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.br branch
git config --global alias.unstage 'reset HEAD'
git config --global alias.last 'log -1'
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
git config --global core.quotepath false # 设置显示中文文件名

==========================================================================================

+工作区 -> git add -> 暂存区 -> git commit -> 版本库 -> git push -> 远程仓库

+版本库HEAD表示当前版本，上一个版本HEAD^，上上一个版本HEAD^^,HEAD~3
+
+配置本机git
+git config --global user.name "abcd"
+git config --global user.email abcd@efgh.com
+
+git连接自己的github
+第一步：创建SSH_key: ssh-keygen -t rsa -C "aaadega@gmail.com",
+        创建成功后.ssh文件下的id_rsa是私钥，id_rsa.pub是公钥
+第二步：登陆GitHub，打开“Account settings”，“SSH Keys”页面
+第三步：添加SSH key，用公钥
+
+一切从版本库同步到远程的git都有uname和pword操作push
+其他都是从本地直接切换操作
+
+一定要从自己的账号下clone仓库，这样你才能推送修改。先fork再clone
+
+git init 初始化此文件夹为版本库
+git add readme.txt 将文件从工作区添加到暂存区
+git checkout -- readme.txt 撤销工作区文件的修改
+git commit -m "this is commit" 将文件从暂存区提交到版本库
+git reset HEAD 从暂存区回退到工作区
+git diff 查看工作区文件修改前后的差异
+git status 查看工作区与暂存区的文件修改状态
+git log 查看提交日志
+git log --pretty=oneline
+git reset --hard HEAD^ 回退到上一版本
+git reflog    查看命令历史
+git remote add origin url 为远程Git更名为origin
+git push -u origin master 首次推送此次修改
+git push origin master 然后可以不加-u
+git clone url 克隆一个远程库到本地
+git branch page 创建新分支
+git checkout page 选择新分支
+git checkout -b page 相当于上面两条一起
+git branch 查看分支
+git merge page 合并分支page到master，checkout到master分支
+git merge page --no-ff -m "plain" 禁用Fast forward
+git branch -d[D] page 删除分支page，删除前先切换到master分支[D强行删除]
+git push origin :page  删除远程分支page
+cat read.txt   查看文件内容（冲突）
+git log --graph 查看分支合并情况
+git log --graph --pretty=oneline --abbrev-commit  查看最近分支合并情况
+git stash 隐藏当前工作区
+git stath list 查看隐藏的工作区
+git stash apply stash{0} 恢复隐藏的工作区，不会删除stash
+git stash drop 删除stash
+git stash pop stash{0} 恢复隐藏的工作区，一并删除stash
+git remote -v 查看远程库信息
+git pull 拉取最新分支
+git branch --set-upstream branchName origin/branchName 指定本地与远程之间的链接
+git tag <name>  可以打一个新标签
+git tag   查看所有标签
+git tag name id  打标签
+-a指定标签名，-m指定说明文字
+git show <tagname>可以看到说明文字
+
+
+有时git clone下来会出现很多branch，更麻烦的是如果主分支没代码那你就只能看到.git目录了。如下:
+git clone git://gitorious.org/android-eeepc/mesa.git
+
+发现本地就只有一个.git目录，那么这个时候就需要checkout了。
+进入你的本地目录，如这个是mesa，利用 git branch Cr
+
+查看branch信息（当然你也可以用git show-branch查看，不过有时并不好用），获得如下branch信息：
+origin/android
+origin/mesa-es
+origin/mesa-es-dri
+
+此时我们需要的是android分支的代码，那么此时就要进行checkout了。
+git checkout origin/android
+
+
+git clone默认会把远程仓库整个给clone下来;
+但只会在本地默认创建一个master分支
+如果远程还有其他的分支，此时用git branch -a查看所有分支：
+
+可以使用checkout命令来把远程分支取到本地，并自动建立tracking
+git checkout -b python_mail.skin origin/python_mail.skin) X& X: I3 Q; ?9 j9 T5 @; J/ M
+或者使用-t参数，它默认会在本地建立一个和远程分支名字一样的分支
+git checkout -t origin/python_mail.skin
+也可以使用fetch来做：
+git fetch origin python_mail.skin:python_mail.skin
+不过通过fetch命令来建立的本地分支不是一个track branch，而且成功后不会自动切换到该分支上- z) 
+

Git中从远程的分支获取最新的版本到本地有这样2个命令：
1. git fetch：相当于是从远程获取最新版本到本地，不会自动merge   
+git fetch origin master
+git log -p master..origin/master
+git merge origin/master
+
+   以上命令的含义：
+   首先从远程的origin的master主分支下载最新的版本到origin/master分支上
+   然后比较本地的master分支和origin/master分支的差别
+   最后进行合并
+   上述过程其实可以用以下更清晰的方式来进行：
+git fetch origin master:tmp
+git diff tmp 
+git merge tmp
+
+   从远程获取最新的版本到本地的test分支上
+   之后再进行比较合并
2. git pull：相当于是从远程获取最新版本并merge到本地
+git pull origin master
+上述命令其实相当于git fetch 和 git merge
+在实际使用中，git fetch更安全一些
+因为在merge前，我们可以查看更新情况，然后再决定是否合并
+结束


============================================================================================

#Git教程 笔记
+> 教程链接：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
+
+##创建版本库
++ `git init`:将当前目录变为Git管理的仓库
++ `git add <filename>`：把文件添加到仓库（stage中）
++ `git commit -m "版本描述"`：把文件按提交到仓库
+
+---------------------
+##时光机穿梭
++ `git status`：显示仓库当前状态
++ `git diff <filename>`：展示文件详细修改内容
+###版本回退
++ `git log`:显示从最近到最远的提交日志
+	+ --pretty=oneline：以单行形式显示提交日志
++ `git reset --hard commit_id`:回退/前进到commit_id指向的版本
++ `git reset --hard HEAD^`:回退到上一版本
++ `git log`:查看提交历史
++ `git reflog`:查看各个版本的commit_id
+
+###管理修改
++ git 管理的是修改，而非文件。
++ 第一次修改 -> git add -> 第二次修改 -> git commit
+
+###撤销修改
++ `git checkout -- <filename>`:丢弃工作区的修改，返回最近一次add/commit时的文件状态
++ `git reset HEAD <filename>`:丢弃暂存区的修改
+
+###删除文件
++ `git rm <filename>`:从版本库中删除文件
+
+--------------------
+##远程仓库
+
+###添加远程库
+1. 登陆GitHub，“Create a new repository”
+2. 添加远程库：`git remote add origin git@github.com:<username>/<repository name>.git`
+3. 推送并关联本地master分支:`git push -u origin master`
+4. 提交master分支修改到远程库:`git push origin master`
+
+###从远程库克隆
++ `git clone git@github.com:<username>/<repository name>.git`
++ GitHub支持ssh/https协议
+
+---------------------
+##分支管理
+
+###创建和合并分支
++ `git branch <name>`:创建分支
++ `git branch`:查看分支
++ `git checkout <name>`:切换分支
++ `git checkout -b <name>`:创建+切换分支
++ `git merge <name>`:合并某分支到当前分支
++ `git branch -d <name>`:删除分支
+
+###解决冲突
++ 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成
++ `git log --graph`:看到分支合并图
+
+###分支管理策略
+1. `git merge <name>`:`fast forward`模式合并，删除分支，分支信息被丢弃
+2. `git merge --no-ff`:普通模式合并，合并后历史有分支，可通过`git log --graph`看到分支合并记录
+
+###Bug分支
++ `git stash`:储存当前工作现场
++ `git stash list`:列出所有stash
++ `git stash apply`:恢复最近一次储存的stash
++ `git stash drop`:删除最近一次储存的stash
++ `git stash pop`:恢复+删除最近一次stash
++ `git stash stash@{num}`:恢复指定stash
+
+###feature分支
++ `git branch -D <name>`:强行删除没有被合并的分支
+
+###多人协作
++ `git remote -v`:查看远程库的详细信息
++ `git checkout -b dev origin/dev`:创建远程origin的dev分支到本地
++ `git branch --set-upstream dev origin/dev`:建立本地分支和远程分支的关联
++ `git pull`:抓取远程的新提交
++ `git push origin branch-name`:从本地推送分支
+
+---------------------
+##标签管理
++ 是指向某个commit的指针
++ 标签不能移动
++ 创建和删除标签都是瞬间完成的
+
+###创建标签
++ `eg：git tag v1.0`
++ `git tag`:列出所有标签（按字母排序）
++ `git tag <tagname>`:新建一个标签，默认为HEAD，也可以指定一个commit id
++ `git tag -a <tagname> -m "description":指定标签信息
++ `git show <tagname>`:查看标签信息
+
+###操作标签
++ `git push origin <tagname>`:推送本地标签到远程库
++ `git push origin --tags`:推送全部未推送过的本地标签
++ `git tag -d <tagname>`:删除本地标签
++ `git push origin :refs/tags/<tagname>`:删除远程标签
+
+---------------------
+##使用GitHub
++ 自己拥有`Fork`后的仓库的读写权限
++ 可以推送`pull request`给官方仓库来贡献代码
+
+---------------------
+##自定义Git
++ `git config --global color.ui true`:让Git显示颜色
+
+###忽略特殊文件
+1. `.gitignore`:配置要忽略的文件
+2. `https://github.com/github/gitignore`:`.gitignore`文件模板
+
+###配置别名
++ 别名是命令的缩写
++ 例子：
+	1. `git config --global alias.st status`:配置status别名为st
+	2. `git config --global alias.co checkout`:
+	3. `git config --global alias.ci commit`:
+	4. `git config --global alias.br branch`:
+	5. `git config --global alias.unstage 'reset HEAD'`:
+	6. `git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"`:
++ 配置文件：
+	1. `.git/config`:仓库的Git配置文件
+	2. `.gitconfig`:当前用户的Git配置文件，放在用户主目录下
+
+---------------------
+##搭建Git服务器
+1. 安装git:`sudo apt-get install git`
+2. 创建git用户:`sudo adduser git`
+3. 创建证书登录：搜集登陆用户公钥（id_rsa.pub）文件，导入`/home/git/.ssh/authorized_keys`文件，一行一个
+4. 初始化Git仓库
+	+ `sudo git init --bare sample.git`
+	+ `sudo chown R git:git sample.git`:修改裸仓库owner，防止其他用户篡改工作区
+5. 禁用shell登陆(git-shell一登陆就自动退出)
+	+ `vi /etc/passwd`
+	+ `git:x:........:/bin/bash`-->`git:x:......:/usr/bin/git-shell`
+6. 克隆远程仓库，本地运行，修改后推送
+	+ `git clone git@server:/srv/sample.git`
+	+ `git push`
+7. 要方便管理公钥，用Gitosis
+8. 要像SVN那样变态地控制权限，用Gitolite

=============================================================================================

+安装Git
+    * 在Linux上安装Git：
+        * Debian或Ubuntu: sudo apt-get install git
+        * 其它Linux通过源码安装git:
+            先从Git官网下载源码，然后解压，依次输入：
+            ./config，make，sudo make install
+    * 在windows上安装Git：
+        * msysgit是Windows版的Git，从http://msysgit.github.io/下载
+        * Tortoisegit是git的客户端        
+        * 安装完设置：（--global参数，表示你这台机器上所有的Git仓库都会使用这个配置）
+            $ git config --global user.name "Your Name"
+            $ git config --global user.email "email@example.com"
+    * git --version
+
+创建版本库
+    * 创建文件夹learngit，用来放置版本库
+    * $ git init
+        把这个目录变成Git可以管理的仓库
+    * $ git add readme.txt
+        编写一个readme.txt文件，放到learngit目录下，通过命令将文件添加到仓库
+    * $ git commit -m "wrote a readme file"
+        把文件提交本地到仓库
+
+时光机穿梭
+    * 查看版本库的状态:（将要被提交的修改包括了什么） 
+        * 修改readme.txt，使用以下命令：
+        * $ git status
+        * $ git diff readme.txt 
+        * $ git add readme.txt
+        * $ git commit -m "add distributed"
+    * 版本回退
+        * $ git log 查看提交历史，以便确定要回退到哪个版本 
+            $ git log --pretty=oneline 可以减少输出信息
+        * $ git reset --hard commit_id 在版本的历史之间穿梭
+            上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100
+        * $ git reflog 查看命令历史，以便确定要回到未来的哪个版本
+    * 工作区和暂存区
+        * 工作区（Working Directory）：就是你在电脑里能看到的目录，比如learngit文件夹就是一个工作区
+        * 版本库（Repository）：工作区有一个隐藏目录.git，这个是Git的版本库。
+            * Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，
+              还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。
+            * 文件往Git版本库里添加的时候，是分两步执行的：
+                * 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区;
+                * 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
+            * 简单理解为：需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。
+    * 管理修改
+        * Git管理的是修改，而不是文件
+        * 每次修改，如果不add到暂存区，那就不会加入到commit中
+    * 撤销修改
+        * 把readme.txt文件在工作区的修改全部撤销，有两种情况：
+            * 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态：
+                * $ git checkout -- readme.txt
+            * 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态：
+                * $ git reset HEAD readme.txt   //把暂存区的修改撤销掉（unstage），重新放回工作区
+                * $ git checkout -- readme.txt  //丢弃工作区的修改
+    * 删除文件
+        * $ git rm test.txt （删除也是修改，将修改信息提交到暂存区）
+            * $ git checkout -- test.txt  //撤销删除
+            * $ git commit -m "remove test.txt"  //从版本库中删除该文件
+
+远程仓库
+    * 设置SSH的私钥和密钥        
+        * 第1步：创建SSH Key  
+            $ ssh-keygen -t rsa -C "youremail@example.com"
+        * 第2步：登陆GitHub
+            打开“Account settings”，“SSH Keys”页面；
+            点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容
+        * 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，id_rsa.pub是公钥
+    * 添加远程仓库
+        * $ git remote add origin git@github.com:gdouchufu/learngit.git 
+            把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库
+        * $ git push -u origin master
+            把本地库的所有内容推送到远程库上
+            （第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，
+            还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。）
+    * 从远程仓库克隆
+        * $ git clone git@github.com:gdouchufu/gitskills.git
+        * Git支持多种协议，包括https，默认的git://使用ssh，通过ssh支持的原生git协议速度最快    
+    
+分支管理
+    * 创建与合并分支
+        * $ git checkout -b dev //创建并切换到dev分支，相当于：
+            $ git branch dev
+            $ git checkout dev
+        * $ git branch
+            查看当前分支
+        * $ git checkout master
+            切换回master分支
+        * $ git merge dev 
+            * 把dev分支的工作成果合并到master分支上
+            * Fast-forward 是“快进模式”，也就是直接把master指向dev的当前提交，合并速度非常快。
+        * $ git branch -d dev
+            删除dev分支
+        * git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全!
+    * 解决冲突
+        * $ git log --graph --pretty=oneline --abbrev-commit
+            --graph 查看分支合并图，--abbrev-commit 只显示commitID的前7位
+            （出现冲突时手动更改冲突文件，把冲突文件add到stage后commit，即可fix冲突）
+    * 分支管理策略
+        * Merge made by the 'recursive' strategy.
+            * 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息；
+            * 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。
+        * $ git merge --no-ff -m "merge with no-ff" dev
+            * --no-ff参数，表示禁用Fast forward
+            * 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。
+        * 分支策略的基本原则
+            * master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活
+            * 干活都在不稳定的的dev分支上，发布版本新时，再把dev分支合并到master上，在master分支发布1.0版本       
+    * Bug分支
+        * $ git stash
+            把当前工作现场“储藏”起来，等以后恢复现场后继续工作
+            statsh : 隐藏，藏匿;贮藏;〈英〉停止
+        * $ git stash list
+            查看保存的工作现场列表
+        * 恢复工作现场的2个方法：
+            * 1、用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除
+            * 2、用git stash pop，恢复的同时把stash内容也删了
+        * $ git stash apply stash@{0}
+            多次stash后恢复的时候，先用git stash list查看，然后恢复指定的stash
+    * 强制删除分支
+        $ git branch -D feature-vulcan
+    * 多人协作
+        * $ git remote     //查看远程仓库信息
+        * $ git remote -v  //显示更详细的信息
+        * 推送分支
+            * 哪些分支需要推送到远程仓库，哪些不需要？
+                * $ git push origin master //master分支是主分支，因此要时刻与远程同步；
+                * $ git push origin dev    //dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
+                * feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。
+            * push失败时，先 git pull ，在本地合并后手动解决冲突，再推送
+        * 抓取分支
+            * $ git pull
+                抓取远程仓库的最新版到当前分支
+            * $ git checkout -b dev origin/dev
+                创建远程origin的dev分支到本地
+            * $ git branch --set-upstream dev origin/dev
+                设置dev和origin/dev的链接
+            * $ git push origin dev
+                将本地的dev分支push到远程的dev分支上           
+
+标签管理
+    * 创建标签
+        * $ git tag 
+            查看所有标签（标签不是按时间顺序列出，而是按字母排序的）
+        * $ git tag v1.0
+            在最新提交的commit上打标签为v1.0
+        * $ git tag v0.9 6224937
+            在commit id为6224937的提交上打标签
+        * $ git show v0.9
+            查看标签信息
+        * $ git tag -a v0.1 -m "version 0.1 released" 3628164
+            创建带有说明的标签，用-a指定标签名，-m指定说明文字
+        * $ git tag -s v0.2 -m "signed version 0.2 released" fec145a
+            通过-s用私钥签名一个标签，签名采用PGP签名，必须先安装gpg（GnuPG）
+    * 操作标签
+        * $ git tag -d v0.1
+            删除本地标签
+        * $ git push origin v1.0
+            推送某个标签到远程
+        * $ git push origin --tags
+            一次性推送全部尚未推送到远程的本地标签
+        * 删除已经推送到远程的标签
+            * 先从本地删除：$ git tag -d v0.9
+            * 再从远程删除：$ git push origin :refs/tags/v0.9
+使用GitHub
+    * 在GitHub上，可以任意Fork开源仓库；
+    * 自己拥有Fork后的仓库的读写权限；
+    * 可以推送pull request给官方仓库来贡献代码。
+
+
+自定义Git
+    * $ git config --global color.ui true
+        * 让Git显示颜色，让命令输出看起来更醒目
+        * --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用
+    * 忽略特殊文件
+        * Git工作区的根目录下创建一个特殊的.gitignore文件，把要忽略的文件名填进去，Git就会自动忽略这些文件
+        * 所有配置文件可以直接在线浏览：https://github.com/github/gitignore
+    * 配置别名
+        * $ git config --global alias.st status
+            用git st代替git status
+        * 用co表示checkout，ci表示commit，br表示branch
+            * $ git config --global alias.co checkout
+            * $ git config --global alias.ci commit
+            * $ git config --global alias.br branch
+        * $ git config --global alias.unstage 'reset HEAD'
+            $ git reset HEAD test.py   -->  $ git unstage test.py
+        * $ git config --global alias.last 'log -1'
+            $ git last //显示最近一次的提交
+        * git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
+            丧心病狂! 方便地查看git log ...
+    * 搭建Git服务器
+        * 第一步，安装git：
+            $ sudo apt-get install git
+        * 第二步，创建一个git用户，用来运行git服务：
+            $ sudo adduser git
+        * 第三步，创建证书登录：
+            收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个
+        * 第四步，初始化Git仓库：
+            先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：$ sudo git init --bare sample.git
+            把owner改为git ： $ sudo chown -R git:git sample.git
+        * 第五步，禁用shell登录：
+            编辑/etc/passwd文件，将git:x:1001:1001:,,,:/home/git:/bin/bash 改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
+        * 第六步，克隆远程仓库：
+            $ git clone git@server:/srv/sample.git


=======================================================================================
#git廖神教程学习总结
+
+##先说点什么：
+前几天开始学习使用github,但一直找不到很全面的教程，这里先感谢廖神，请收下我的膝盖。
+首先说一下对githug的理解吧，githug是一个分布式的项目版本托管平台，无论是个人项目还是多人协作
+的
+项目，都能轻松做到版本托管。更重要的是，github使得多人协作的项目变得简单易行，并且能离线工作
+。身为菜鸟的我装逼结束，装逼可以，但不要太过分！
+
+##github的使用：
+github有本地库和远程库之分，远程库就是github上大家都可以看到，可以fork，可以clone的库，是大家
+共享的。而本地库是你个人离线工作的地方，当你参与到一个项目之中（无论是你创建的项目还是别人的
+项目），你都先要把当前已经存在的项目从远程库clone到本地库上，然后才开始工作，例如为项目增加新
+的功能。当你完成你的工作后，就可以把你本地库里的已经加了新的功能的项目push到远程库，如果是别
+人的项目，你还需要进行pushrequest操作，进行合并库请求。请求项目的发起者将原本的项目和你实现了
+新的功能的代码进行合并库，这时项目的发起者就会对你的代码进行测试，何不合并库就看你的代码硬不
+硬咯！
+
+##从廖神教程里总结出来的一些命令操作：
+
+##1.如果你想发起一个项目，首先可以建立一个本地仓库
+
+//首先要在github路径下建立一个文件夹
+mkdir rep-name
+//进入该文件夹
+cd rep-name
+//把这个目录变成Git可以管理的仓库
+git init 
+//开始工作，例如在rep-name文件夹下建立一个readme.txt文件，把文件加入暂存区,注意大小写要匹配
+git add readme.txt
+//把readme.txt提交到当前分支上，提交又叫commit
+git commit -m "关于本次提交你想记录点什么"
+
+在这个过程中，可以使用 git statuus 查看当前工作区，暂存区，分支状态。使用git diff可以查看修改
+的内容。
+
+##2.坐在时光机，在时空中穿梭
+在工作中，你不断的提交修改。有时你脑子有点乱，把文件改坏了，或者误删了文件，就可以使用git的版
+本回退功能对文件进行恢复。
+
+//查看commit记录
+git log
+//HEAD是一个指针，指向我们当前版本，HEAD^表示前一个版本，HEAD~100表示第前100个版本
+//以下为版本回退操作
+git reset --hard HEAD^
+//这样你就可以回到之前的一个版本了
+//你还可以使用通过commit记录查询到commit id,通过commit id进行版本回退
+git reset --hard commit id（前几位就好）
+//还可以使用git reflog 查看命令历史
+
+##3.工作区和暂存区：		
+
+工作区(work directory)就是我们在电脑里能看到的目录，比复foo文件夹
+版本库(repository)工作区有一个隐藏目录.git，它不属于工作区，而是git的版本库
+git的版本库里存在了很多东西，其中最重要的就是：
+称为stage(或者叫index)的暂存区
+git为我们创建的第一个分支master
+指向master的指针HEAD
+
+//把文件添加到暂存区
+git add file_name
+//把暂存区文件提交到当前分支
+git commit
+//因为只有默认创建的master分支，所以commit就是往master分支提交
+//因为每次commit的都是暂存区的内容，所以没有被add的内容不会被commit
+//使用如下命令可以比较工作区文件和暂存区文件的异同
+git diff -- file
+
+好累啊
+我不想再解释那么多了，记录命令就好了。。。。。
+
+##4.撤销修改和删除文件
+
+//撤销工作区的修改
+git checkout --filename
+//撤销已经提交到暂存库stage中的修改
+git reset HEAD filename
+//撤销已经提交到分支上的修改，请用上面讲到的版本回退
+//删除本地文件
+rm filename
+//必须保持版本库文件和工作区文件的一直，所以你这时候还得删除版本库中的文件，或者撤销上步操作
+//删除版本库中文件
+git rm filename
+
+##5.远程仓库
+github 一个神奇的网站
+
+关联本地仓库和远程仓库
+首先要上github官网申请一个账号（我们欢迎你来，但是你要做个报告。。）
+
+由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，还需要一点设置：
+第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa
+和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git
+ Bash），创建SSH Key：
+ssh-keygen -t rsa -C "your email_address"
+接下来的步骤请百度。。。
+
+//把本地仓库与一个空的远程仓库相关联, 在本地的一个仓库下，例如learngit下运行
+git remote add origin git@github.com:you_github_username/learngit.git
+//第一次推送master分支的所有内容
+git push -u origin master
+//以后推送使用
+git push origin branch_name
+//只有把本地仓库与空的远程仓库关联时需要手动建立连接，当我们从远程仓库clone项目到本地时会自动
+建立关联，关联名自动设置为origin
+
+//从远程仓库clone项目到本地仓库
+git clone http/ssh
+
+##6.是时候开始建立分支了
+在一个多人合作的项目中，切记master是主线，也是稳定版本库。我们每个人都应该在master绳新建一个分支，在分支上工作，分支是不稳定的，master是稳定的，当工作完成后，再将master和分支merge。
+
+//创建分支
+git branch dev
+//版本库从master切换到分支dev上
+git checkout dev
+//也可以一气呵成
+git checkout -b dev
+//查看所有分支
+git branch
+//在分支上完成工作，合并master和当前分支，首先切换回master
+git checkout master
+//合并当前分支到某分支
+git merge dev
+//删除分支
+git branch -d dev
+//如果master分支和子分支有conflict，则先要解决冲突，再进行合并
+
+bug分支：
+git分支管理非常强大，每个bug都可以使用临时分支来解决，合并后就可以删除了
+一个很常见的bug修复流程:
+//首先使用git stash将当前工作区储藏起来，以备日后恢复工作
+git stash
+//这时又是干净的工作区了，若要在master上修复bug，切换到master分支
+git checkout master			
+//创建并切换到bug分支issue-101
+git checkout -b issue-101		
+//修复bug完成后，切换到master分支，并完成合并，然后删除bug分支
+git checkout mater		切换到master分支
+git merge --no-ff issue-101 -m "merge bug fix 101"	合并分支
+git branch -d issue-101	删粗bug修复分支
+//bug解决后，切换回dev分支
+git checkout dev
+//要恢复stash起来的工作区，首先使用下面的命令查看stash list
+	$ git stash list
+//要恢复工作区，方法一,恢复stash@{0}存储的工作区,然后删除stash{0}
+git stash apply stash@{0}	
+git stash drop stash@{0}	
+//要恢复工作区，方法二，恢复工作区，并删除stash
+git stash pop			
+
+feature分支：
+开发时，有时候希望添加一些新功能，但我们不希望实验性的代码把主分支弄坏,可以创建feature分支，
+在上面开发，完成后再合并，删粗
+//首先新建一个feature分支
+git checkout -b feature-newfun
+//开发完成后回到dev分支，准备合并
+git checkout dev
+//如果一切顺利就可以合并并删除feature分支了
+git merge --no-ff feature-newfun -m "add new fun"
+git branch -d feature-newfun
+//如果这时情况有变，要取消新功能，我们就需要销毁feature分支
+git branch -d feature-newfun 
+//这时会销毁失败，因为新的分支还没有合并，需要强制销毁
+git branch -D feature-newfun
+//至此删除feature分支完成
+
+##7.多人协作
+当我们从远程仓库中克隆的时候，git只把本地master分支和远程的master分支关联了，并且远程仓库的默
+认名称是origin。
+//查看远程库的信息
+git remote -v
+master是主分支，因此要时时刻刻与远程分支同步
+dev是开发分支，团队成员都要在上面工作，因此也要时刻与远程分支同步
+bug分支只用在本地修复bug，没必要推送，除非老板要看你每周修复几个bug
+feature分支是否推送，取决于你是否和小伙伴合作在上面开发
+
+//抓取dev开发分支
+git checkout -b dev origin/dev
+//从本地push分支到远程库
+git push origin branch_name
+//如果有冲突，使用git pull 抓取远程库中最新的更新
+git pull
+//在本地解决冲突后再push到远程库
+
+##8.标签管理
+发布一个版本时，我么常常现在版本库中打一个标签，这样就唯一确定了打标签时候的版本，将来无论什
+么时候，随时都可以取出打标签的版本，其实就是一个版本快照，git的标签也是一个指针，和分支很像，
+不同的是，分支可以移动，而标签不能移动
+
+创建标签：
+//首先切换到要打标签的版本
+git checkout master
+//然后使用如下的命令打标签
+git tag v1.0
+//可以使用如下的命令查看所有标签
+git tag
+//打标签默认是打在最近的commit上的，如果要给历史版本打标签,就要先找到历史的commitid再给它大上
+git log --pretty=oneline --abbrev-commit
+git tag v0.9 633834
+注意标签不是按照时间排序，而是按照字母排序的,使用git tag <tagname>查看标签信息还可以创建带
+说明的标签，使用-a指定标签名，-m指定说明
+git tag -a v0.1 -m "this is a tag" 632345
+//还可可以使用-s用私钥签名一个标签
+git tag -s v0.2 -m "signed version 0.2 released" f234b3
+//签名使用GPG签名，所以必须先安装了GunPG，并且有gpg密钥对
+
+操作标签：
+//删除标签：
+git tag -d v0.1
+//推送标签到远程
+git push origin <tagname>
+//或者可以一次性推送所有本地标签
+git push origin --tags
+//删除远程标签，要先删本地的，再删远程的
+git tag -d v0.1
+git push origin :refs/tags/v0.1


==================================================
+===========================================
+1.将本地仓库与远程仓库关联
+   git remote add origin git@github.com:ddcat1991/learngit.git
+2.将本地内容推送到远程仓库
+	git push -u origin master
+	其中 origin远程仓库,master为分支名	由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
+
+=======================================================================
+1.克隆远程库到本地
+	git clone git@github.com:michaelliao/gitskills.git
+
+=======================================================================
+关于分支
+	1.创建dev分支
+	git checkout -b dev
+	-b表示创建切换: 相当于 $git branch dev  $git checkout dev
+	
+	2.查看分支
+	$git branch
+	
+	3.切回到master分支
+	$ git checkout master
+	
+	4.合并指定分支到当前分支
+	$ git merge dev
+	
+	5.删除分支
+	$git branch -d dev
+		--强制删除未合并的分支
+		  $git branch -D <分支名>
+	
+	6.查看分支合并情况
+	git log --graph --pretty=oneline --abbrev-commit
+	
+	7.合并分支,禁用fastforward
+	$ git merge --no-ff -m "merge with no-ff" dev
+	
+	8.Bug分支--储存工作现场
+		$git stash
+		关于恢复
+		$git stash apply
+		$git stash pop
+		
+	
+		
+===================================================================
+关于远程仓库
+	1.获取远程仓库信息
+		$git remote -v
+	2.推送分支
+		$git push origin master
+						-分支名
+	3.创建远程分支到本地
+		$ git checkout -b dev origin/dev
+	4.从远程抓取
+	  $ git pull
+	  
+==================================================================
+关于标签
+	1.添加标签
+		$git tag v1.0
+		$git tag v0.9 622493706
+		
+	2.带有说明的标签
+		$ git tag -a v0.1 -m "version 0.1 released" 3628164

====================================================================================
+git init 创建版本库
+git add 添加文件到缓冲区
+git commit -m ‘xxx’ 提交到本地仓库
+git status 查看当前目录状态
+git diff 查看文件变化的内容
+git reset --hard HEAD^ 回退到上一版本, git reset --hard HEAD^^ 回退到上上版本,git reset --hard HEAD~100 回退到上100个版本，git reset ―hard <commit id前几位>  回退到指定版本
+git reflog 查看历史版本，如果有需要，随后可以根据显示的commit id进行回退
+git add后如果又修改了，此时git commit只会提交add过的版本，后面修改的不会提交
+git checkout -- <file> revert文件到add过或最新的版本，先add的版本，再最新的版本
+git reset HEAD <file> 可以撤销git add的版本
+场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
+
+场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。
+
+场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。
+
+
+git rm 会同时删除仓库里的文件和本地文件，但是在提交之前，还是可以通过git reset HEAD && git checkout ―- <file>恢复文件
+git rm 相当于本地rm <file> 再git add
+git remote add origin git@server-name:path/repo-name.git 关联一个远程库
+git push -u origin master第一次推送master分支的所有内容
+git push origin master推送最新修改(对远程库非第一次)
+git branch 查看分支
+git branch <name> 创建分支
+git checkout <name> 切换分支
+git checkout -b <name> 创建+切换分支
+git merge <name> 合并某分支到当前分支
+git branch -d <name> 删除分支
+git log ―graph 查看分支合并图
+git stash 保存工作现场
+git stash list 查看保存的stash
+git stash apply stash@{n} 恢复指定的stash
+git stash pop stash@{n} 恢复现场并删除该stash
+如果一个分支没有被合并过，git branch -d feature 会被友情提醒，需要通过git branch -D feature 强行删除
+git tag <name>新建一个标签，默认为HEAD，也可以指定一个commit id；
+git tag -a <tagname> -m "blablabla..."可以指定标签信息；
+
+git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；
+git tag可以查看所有标签。
+git push origin <tagname>可以推送一个本地标签；
+git push origin --tags可以推送全部未推送过的本地标签；
+git tag -d <tagname>可以删除一个本地标签；
+git push origin :refs/tags/<tagname>可以删除一个远程标签。

======================================================================================
+?$ git config --global user.name "Your Name"
+$ git config --global user.email "email@example.com"
+通过git init命令把这个目录变成Git可以管理的仓库：
+用命令git add告诉Git，把文件添加到仓库：$ git add readme.txt
+Unix的哲学是“没有消息就是好消息”
+用命令git commit告诉Git，把文件提交到仓库：$ git commit -m "wrote a readme file"
+add会把修改放到暂存区，commit会把暂存区里的内容提交到当前分支。
+时刻注意git status,查看修改差异，利用git diff,commit前要add.
+利用git log来查看我们队文件都做了哪些改动。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：
+
+如何回退：
+1.首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。
+2.就可以使用git reset命令来回退，如git reset --hard HEAD^(回退到上一个版本)
+3.如果当前页面没有消失可以找到版本的id,页面如果要回去可以用$ git reset --hard 3628164，这两个步骤主要是把指针来回的移动罢了。
+4.要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。查看commit id就行。
+
+GIT管理的是修改，add是把修改放到了暂存区，commit是把暂存区的修改提交，所以每次修改一定要add，
+
+命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
+
+一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
+
+一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
+
+总之，就是让这个文件回到最近一次git commit或git add时的状态。
+
+git checkout -- file命令中的--很重要，没有--，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。
+
+Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：
+
+*******************************************************************************
+梳理一下：首先文件夹下有两个部分，工作区和版本区，在工作区中是我们实体的文件copy,在版本区中是进行版本控制的内容(也就是修改和工作区的最新文件备份)，其中管理的是修改。我们用的git xx命令就是在版本区执行的，我们用的rm,touch等是在工作区执行的。在工作区执行后，就产生了一次修改，git把这些修改放到版本区的暂存区（利用add命令），如果没有放到暂存区的话，git status会有说明的，因为我们只有把修改放到暂存区中我们才可以进行提交等（因为暂存区给了我们一次可以反悔的机会，我们可以checkout 和 reset）.
+举一个比较好的例子：删除工作区的一个文件rm test.txt,这对于GIT来说是一个修改，这个修改会立刻反应给GIT（因为它在工作区已经不存在了，所以add到暂存区是没有意义的），如果你真的要删除他的话，可以用git rm test.txt 把他也从版本库中删除，然后git commit 提交，这样版本库中和工作区中都没有了，如果是误删除，因为版本区里还有一个最新的备份，因此可以用checkout回复到工作区。
+
+*******************************************************************************
+
+实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。
+
+当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。
+一、推送给远程
+1.我们根据GitHub的提示，在本地的learngit仓库下运行命令：
+现在github上创建一个learngit.git的repo然后在本地git文件夹下运行。
+$ git remote add origin git@github.com:michaelliao/learngit.git//或者是http://github.com/banjnax/LeaGit.git
+请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。
+添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。
+2.下一步，就可以把本地库的所有内容推送到远程库上：$ git push -u origin master
+把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。
+由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
+3.此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；
+
+二、从远程拉去
+1.$ git clone git@github.com:michaelliao/gitskills.git//或者http://github.com/banjnax/LeaGit.git
+之后会在本地创建一个相对应的文件夹
+
+三、分支的创建于使用
+HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。
+一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：
+当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：
+1.命令
+$ git checkout -b dev
+git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
+$ git branch dev
+$ git checkout dev
+然后，用git branch命令查看当前分支：
+
+$ git branch
+* dev
+  master
+git branch命令会列出所有分支，当前分支前面会标一个*号。
+git push origin MyBr//把分支push到远端
+2.合并分支内容到master
+$ git merge dev//注意这个事在master分支内运行的，表示把master合并到dev分支处
+3.合并完成后，就可以放心地删除dev分支了：$ git branch -d dev
+4.注意在本地push到远端，如果想保持同步，需要把分支和master分别push到github。删除了本地分支就不能再本地同步到github上了，需要自己在github上删除，不过话又说回来了，一般来说我们只是clone远端的master,然后在本地建一个分支，然后在本地分支上修改什么的，然后合并为master,最后通过master push到github，最后在本地删除我们的分支。所以。。把我们的分支push 到github上是没有必要的。
+
+四、冲突
+1.如果多个分支对同一个文件进行了修改提交，并且分支之间进行了meger就会发生冲突。
+2.解决，我们在master上修改冲突文件，因为这是一个修改所以我们add,commit就好了，这时master比其他分支多一层，就解决了冲突问题。git log --graph命令可以看到分支合并图。
+
+--no-ff参数，表示禁用Fast forward：//merge时
+合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。
+五、stash
+对于你在分支上工作时，突然来了另一个紧急的任务，但是你的工作还没有做完怎么办呢，那就是先把当前的现场环境保留下来git stash；然后就可以去做其他事了，做完了其他事，回到本分支，用git stash list命令看看保留的现场环境：工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：
+
+一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
+
+另一种方式是用git stash pop，恢复的同时把stash内容也删了：
+你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
+
+$ git stash apply stash@{0}
+
+六、多人协作
+多人协作的工作模式通常是这样：
+首先，可以试图用git push origin branch-name推送自己的修改；
+
+如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
+
+如果合并有冲突，则解决冲突，并在本地提交；
+
+没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！
+
+如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。
+
+这就是多人协作的工作模式，一旦熟悉了，就非常简单。
+七、标签
+在Git中打标签非常简单，首先，切换到需要打标签的分支上：
+然后，敲命令git tag <name>就可以打一个新标签：
+
+$ git tag v1.0
+可以用命令git tag查看所有标签：
+
+$ git tag
+v1.0
+默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？
+
+方法是找到历史提交的commit id，然后打上就可以了：
+比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：
+
+$ git tag v0.9 6224937
+注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：
+还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：
+
+$ git tag -a v0.1 -m "version 0.1 released" 3628164
+用命令git show <tagname>可以看到说明文字：
+如果标签打错了，也可以删除：
+
+$ git tag -d v0.1
+因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。
+
+如果要推送某个标签到远程，使用命令git push origin <tagname>：
+或者，一次性推送全部尚未推送到远程的本地标签：
+
+$ git push origin --tags
+
+如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，
+一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。
+
+如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。
+
+如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。
+
+如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。


=============================================================================

+关于工作目录(working directory)、暂存区(stage/index)、版本库(commit)
+
+及版本回退的难点图示解析:
+
+                     ___________版本库（Repository）__________
+                    |                                         |
+      工作区/目录   |      暂存区           分支              |
+  working directory |   stage/index      当前master  ←HEAD    |
+         1          |        1               1                |
+         ↑        add        ↑     commit    ↑                | 
+         |        ----->     |     ----->    |                | 
+         |          |        |               |                |
+         2          |        2               2                |
+ ②.checkout --     |  ①.reset HEAD     ③.reset --hard      |
+                    |_________________________________________|      
+
+                                  
+                 <--diff-->    <--(--cached)-->
+          <----------------HEAD--------------->
+
+暂存区清空操作：   
+ git reset HEAD test.txt 是指清空了暂存区,，你所有的git add且没有git 
+
+coomit的修改都将清空；
+
+回退提交的版本：
+ git reset --hard HEAD^
+ git reflog
+ git reset --hard 版本号（commit_id）
+ 其实都是用最新的版本(commit)还原
+ --------------附送删除及恢复操作------------------------------
+    rm file __恢复--> checkout -- file
+           | 
+           |__删除--> git rm & commit
+		   
+       wd  index  commit
+        1    1      1
+ rm     N    1      1
+git rm  N    N      1
+commit  N    N      N

--------------------------------
+|---github----------------------------|
+|               ①fork                |
+|liao/learngit ------> amtree/leargit |
+|              <------      ↑  |      |
+|          ⑤pull request   |  |      |
+|___________________________|__|______|
+                            |  |
+                     ④push |  | ②clone
+                            |  ↓
+                          local/leargit
+                       ③ur file、add、commit

======================================================================================

+##Git 初步
+初始化一个Git仓库，使用`git init`命令。
+
+添加文件到Git仓库，分两步：
+
+1. 使用命令`git add <file>`，注意，可反复多次使用，添加多个文件；
+2. 使用命令`git commit`，完成。
+通常使用 `git commit -m "something to comment"`
+3.  注意，每次commit前都先要`add commit`,如果在commit前没有add，那么只会commit到之前add时候的内容
+
+##Git查看
+* 要随时掌握工作区的状态，使用`git status`命令。
+* 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。
+* 使用`git log`来查看git commit记录 
+* 也可以使用`git log --pretty=oneline` 一行显示
+
+##版本回退
+HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令：
+
+* `git reset --hard commit_id` 回退到id的版本
+* `git reset --hard HEAD^` 	 回退一个版本
+* `git reset --hard HEAD^^`   回退两个版本
+* `git reset --hard HEAD~100` 回退一百个版本
+
+穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。
+要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。
+
+##工作区与暂存区
+`git add`命令实际上就是把要提交的所有修改放到暂存区（Stage）
+
+![git add](/Users/Des/Documents/Coding/notes/image/git add.jpeg)
+`git commit`就可以一次性把暂存区的所有修改提交到分支。
+
+![git commit](/Users/Des/Documents/Coding/notes/image/git commit.jpeg)
+
+##撤销修改 撤销删除
+删除文件 使用 rm file，但是如果想要版本库也删除的话 需要使用 `git rm file`
+
+1. 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。 git checkout其实是用版本库里的版本替换工作区的版本，如果在无论工作区是修改还是删除，比如不小心删掉文件了，使用`git checkout --file`都可以“一键还原”，将这个工作区的文件用版本库里边的恢复。
+
+2. 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，即已经进行了`add`操作，想丢弃修改，分两步，第一步用命令`git reset HEAD file`，就回到了场景1，第二步按场景1操作。
+
+3. 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。
+
+##远程连接
+####从本地拷贝到远程库
+cd到要拷贝的git的文件夹
+
+1. 要关联一个远程库，使用命令 `git remote add origin git@server-name:path/repo-name.git`； 
+2. 比如 `git remote add origin git@github.com:rwang23/xx.git`
+
+2. 关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容,如果不是master分支，换名字就可以；
+
+3. 此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；
+
+分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！
+
+####从远程库克隆到本地
+进入要克隆到的文件夹，
+`git clone git@github.com:michaelliao/gitskills.git`
+Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。
+
+##分支管理
+Git鼓励大量使用分支：
+
+* 查看分支：`git branch`
+* 创建分支：`git branch <name>`
+* 切换分支：`git checkout <name>`
+* 创建+切换分支：`git checkout -b <name>`
+* 合并某分支到当前分支：`git merge <name>`
+* 删除分支：`git branch -d <name>`
+* 开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。
+
+合并分支的时候如果出现冲突，那么将会出现冲突提醒
+并在当前分支上出现：
+
+	<<<<<<< HEAD
+	Creating a new branch is quick & simple.
+	=======
+	Creating a new branch is quick AND simple.
+	>>>>>>> feature1
+修改好后再次提交就可以了
+同时 可以使用 git log 或者git log --graph指令来查看分支与分支合并情况
+
+通常情况下使用合并分支Git会自动使用`Fast forward`模式，但是这种情况下删除分支后，会丢失分支信息，
+这个时候我们可以使用--no-ff方式下的`git merge`，它会提交一个新的commit 
+`git merge --no-ff -m "merge with no-ff" dev`
+
+
+###分支策略
+
+* master分支应该是非常稳定的，也就是仅用来发布新版本的
+* 一般干活都在dev分支上的，一般来说dev分支是不稳定的，比如到了某个时候才合并到master上边，在master上边发布新版本
+![git branch merge](/Users/Des/Documents/Coding/notes/image/git branch&merge.png
+
+####Bug出现的修复
+
+* 当正在新的branch进行工作时，想要修复原来的branch比如master的bug，这个时候就想切换到master。
+
+* 但是此时由于branch还没完成不能提交，所以我们可以使用`git stash`来储存当前工作现场
+
+* 然后就可以切换到要修改Bug的branch然后创建bug新分支再用原分支合并，再切换到刚才的新brach工作
+
+如何储存工作现场？
+
+1. 使用`git stash`来储存当前工作现场
+
+2. 可以使用`git stash list`来查看当前工作现场
+
+3. 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：
+
+* 一是用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；
+
+* 另一种方式是用`git stash pop`，恢复的同时把stash内容也删了：
+
+##多人协作
+查看远程库信息，使用git remote -v；
+
+多人协作的工作模式通常是这样：
+
+1. 首先，可以试图用git push origin branch-name推送自己的修改；
+
+2. 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
+
+3. 如果合并有冲突，则解决冲突，并在本地提交；
+
+4. 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！
+
+5. 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。
+
+这就是多人协作的工作模式，一旦熟悉了，就非常简单。
+
+##标签管理
+
+###创建标签
+* 命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；
+* git tag commit_id 在该commit_id上打上标签 
+* git tag -a <tagname> -m "blablabla..." commit_id可以指定标签信息；
+* git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；
+* 命令git tag可以查看所有标签。
+
+###修改标签
+因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。
+
+* 命令`git push origin tagname`可以推送一个本地标签；
+* 命令`git push origin --tags`可以推送全部未推送过的本地标签；
+* 命令`git tag -d tagname`可以删除一个本地标签；
+* 命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签。


=====================================================================================

+#Git 学习笔记
+##基本命令
+1. 创建版本库
+	- **`git init`**
+	- 在指定文件目录（不一定为空）下创建由Git管理的仓库
+	- 隐藏文件 `.git` 是Git来跟踪管理版本库的
+2. 添加文件到仓库
+	- **`git add <filename>`**
+	- 可以多次add不同文件
+3. 提交文件到仓库
+	- **`git commit -m "message"`**
+	- -m后面输入的是本次提交的说明
+	- 一次可以提交多个文件
+4. 查看仓库当前的状态
+	- **`git status`**
+5. 查看修改的内容
+	- **`git diff <filename> <filename>`**
+	- `git diff HEAD^ HEAD`
+6. 查看提交历史
+	- **`git log`**
+	- 显示从最近到最远的提交日志
+	- **`git log --pretty=oneline`** 只显示commit id信息
+7. 查看命令历史
+	- **`git reflog`**
+	- 找回历史版本的commit id
+8. 版本回退
+	- **`git reset --hard <option>`**
+	- HEAD表示当前版本，HEAD~N表示上N个版本
+	- commit id（前几位即可）表示对应版本
+	- option可为HEAD~N或commit id
+9. 撤销修改
+	- **`git checkout -- <filename>`**
+	- 若文件还没有添加到暂存区，如果文件被修改，则恢复到和版本库一样的状态
+	- 若文件已经被添加到暂存区，如果文件被修改，则恢复到添加到暂存区后的状态
+	- 让文件回到最近一次commit或add的状态
+	- 若要**丢弃暂存区中内容**，使用命令 **`git reset HEAD <filename>`**
+10. 删除文件
+	- **`rm <filename>`** 删除工作区文件
+	- 若为误删，恢复可使用命令 **`git checkout -- <filename>`**
+	- 若非误删，先使用命令 **`git rm <filename>`**，然后使用命令 **`git commit`**
+	- 命令 **`git rm <filename>`** 会删除工作区对应文件
+11. 关联GitHub
+	- **`git remote add origin git@server-name:path/repo-name.git`**
+	- origin是远程库的名字，也可以改成其他的
+	- 命令 **`git push -u origin master`** 将本地库内容推送到远程库
+	- `-u` 参数不但会把本地的master分支内容推送到远程新的master分支，还会把它们关联起来，在以后的推送或者拉取时就可以简化命令，只需输入 **`git push origin master`** 即可
+	- 命令 **`git clone git@server-name:path/repo-name.git`** 将远程库克隆至本地
+	- Git支持多种协议，但通过SSH支持的原生Git协议速度最快
+
+##工作区和暂存区
+- 工作区即电脑中能看到的目录
+- `git add` 将工作区中要提交修改的文件添加到暂存区
+- `git commit` 提交更改，一次性将暂存区中的内容提交到当前的分支
+- git会自动创建第一个分支`master`
+- git管理的是修改而不是文件

========================================================================
创建用户：（注明自己的身份）
+git config --global user.name "username"
+git config --global user.email "useremail"
+
+初始化：(进入相应文件夹后，在该文件夹初始化版本库)
+git init
+
+添加项目：（添加your file到版本库）
+git add (your file)
+
+添加注释信息：（为当前创建版本写上注释）
+git commit -m "your message"
+
+查看当前版本状态：
+git status
+
+查看修改内容：
+git diff
+
+查看日志：
+git log [file name]
+git log --pretty=oneline	//将日志显示到一行，每行之包括sha1码和注释信息
+				//这里的sha1码即为一个版本的ID（commit id）
+				//如果加上--abbrev-commit参数会将sha1码通过简写的方式显示
+
+回退版本：
+git reset --hard HEAD^		//HEAD后面的^的数目代表要回退的版本数
+git reset --hard HEAD~n		//n代表要回退的版本数
+git reset --hard (commit id)	//回退到相应commit id的版本，id不用写全，一般7位就够了
+
+查询回退日志：
+git reflog
+
+显示文档内容：
+cat （file）
+
+查看工作区和暂存区的区别：
+git diff HEAD -- (file)
+
+撤销最近一次对文件修改：
+git checkout -- (file)		//将文件回到最近一次git commit或git add的状态
+				//当误删除文件时可以使用此命令从git仓库还原此文件
+				//不加--就会变成创建一个分支
+
+撤销最近一次提交到暂存区的文件:
+git reset HEAD (file)		//将最近一次add到stage的文件退回
+
+克隆项目到远程库：
+git remote add origin git@server-name:path/repo-name.git
+				//origin为远程库的名字，可以改变，但习惯上叫origin
+git remote			//显示远程仓库名字
+git remote -v			//显示远程仓库详细信息
+git branch --set-upstream branch-name origin/<branch-name>
+				//将本地分支与远程分支关联
+
+将本地库推送到远程：
+git push [-u origin master]	//实际上相当于将本地的master分支内容推送到远程新的master分支
+				//并且将本地master与远程关联，方便以后的推送
+				//以后在本地推送时只需要输入git push origin master
+
+从远程库克隆仓库：
+git clone git@server-name:path/repo-name.git
+
+创建分支：
+git branch (branch-name)	//创建一个名字为branch-name的分支
+git checkout (branch-name)	//移动到branch-name分支
+git checkout -b (branch-name)	//-b参数为创建并切换，相当于上述两条命令组合
+git branch			//列出所有分支，并在当前分支前面会标一个*号。
+
+合并分支：
+git merge (branch-name)		//将指定分支（branch-name）合并到当前分支
+git log --graph			//查看分支合并图
+
+删除分支：
+git branch -d (branch-name)	//删除指定分支
+git branch -D <branch-name>	//强制删除指定分支
+
+分支管理：
+git merge --no-ff -m "<msg>" <branch-name>
+				//不使用fast forward模式合并分支，这样会在morge时添加一个commit
+				//-m参数后面即为描述信息
+
+保存现场：
+git stash			//用于保存当前工作区、暂存区现场
+git stash list			//列出当前已经存在的现场
+git stash apply <stash-name>	//跳转到<stash-name>现场，但是它本身并没有删除
+git stash drop <stash-name>	//删除<stash-name>
+git stash pop			//跳转到最新的现场，并删除（弹出）
+
+标签管理：
+git tag				//查看标签
+git tag <tag-name>		//创建一个<tag-name>的tag
+git tag <tag-name> <commit-id>	//在<commit-id>位置创建一个tag（用于给先前提交过的版本创建tag）
+git show <tag-name>		//显示<tag-name>的详细信息
+git tag -a|-s <tag-name> -m <msg> <commit-id>
+				//创建带注释的标签。-m后接注释内容。
+				//使用-a参数则创建的是公共tag。使用-s参数则会使用私钥创建带签名
+				//的标签。（使用PGP签名，需要安装GnuPG）
+git tag -d <tag-name>		//删除<tag-name>标签
+git push origin <tag-name>|--tags
+				//推送<tag-name>到远程库或一次性推送全部标签
+git push origin :refs/tags/<tag-name>
+				//删除远程库的tag。首先删除本地tag，然后通过此格式推送到远程


